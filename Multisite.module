<?php

/**
 *
 * Multisite module for Processwire
 * (C) 2012 Antti Peisa, Avoine Oy
 *
 * Modifications by Philipp "Soma" Urlich
 * - support Multilanguage
 * - support for correct view Actions from admin
 * - correct urls within admin (TODO: make that configurable, so one can turn off
 * and add a url textformatter parser for replacing urls on output)
 * - modified locaUrl() to work correctly, coming from LanguageSupportNames module
 *
 *
 * ProcessWire 2.x
 * Copyright (C) 2010 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class Multisite extends WireData implements Module {

	public $domains;
	static $domainsData;
	public $site; // store current domain config array for convenience

	/* NOTE, TODO: XML Sitemap by Pete listen to this property, but it was changed in this module from subdomain to domain. */
	public $domain;


	public static function getModuleInfo() {
		return array(
			'title' => 'Multisite',
			'version' => 008,
			'summary' => 'Allows multiple sites with different domains run from single PW-site and database.',
			'singular' => true,
			'autoload' => true
			);
	}

	public function __construct() {
		// read config settings
		if(!wire("config")->MultisiteDomains) {
			$this->domains = array();
		} else {
			$this->domains = wire("config")->MultisiteDomains;
		}

		$this->site = "";

	}

	public function init() {


		// domains from the config
		if(!count($this->domains)) return;


		$this->it = (isset($_GET['it'])) ? ltrim($_GET['it'], '/') : '';
		$this->isAdmin = false;
		$this->isAssets = false;
		$this->isFormBuilder = false;
		$this->domain = '';
		$httpHost = strtolower(wire('config')->httpHost);

		$rootUrl = rtrim(wire('config')->urls->root, '/');

		// if in admin, we store that for later usage
		if(strpos($rootUrl . $this->it, trim(wire('config')->urls->admin, '/')) === 0) {
			$this->isAdmin = true;
		}

		// if it's an assets file request and not a page, we don't need to modify "it"
		if(strpos($rootUrl . $this->it, ltrim(wire('config')->urls->assets, '/')) === 0){
			$this->isAssets = true;
		}

		// if it's form-builder
		if(strpos($rootUrl . $this->it, "/form-builder/") !== false){
			$this->isFormBuilder = true;
		}

		// exclude calls from PW front-end editing
		if($this->wire("input")->post->action == "PageFrontEditSave") return;

		// check for root domain name in url and redirect to domain if found
		$this->_checkDomainInUrl();

		if(array_key_exists($httpHost, $this->domains)) {

			// set the current domain, so it can be picked up in templates or other modules
			$this->domain = $httpHost;
			$this->site = $this->domains[$httpHost];
			$this->set404Page($this->domain);
			$domainPageName = $this->domains[$httpHost]['root'];

			// if the requested URI is an admin url we don't need to go further
			// we just need to make sure the $this->domain is set, as it's may be
			// used later in other modules to modify the url, or localUrl()
			if($this->isAdmin) return;

			// if requested url is a file we don't change
			if($this->isAssets) return;

			// if requested url is a file we don't change
			if($this->isFormBuilder) return;

			// language page names support if installed
			// strip off the lang segment, to later prepend it again
			$this->langSegment = '';
			if($this->modules->isInstalled("LanguageSupportPageNames")) {
				foreach($this->languages as $lang) {
					$langID = $lang->id;
					if($lang->isDefault()) $langID = '';

					$rootPage = $this->pages->get(1);
					$rootName = $rootPage->get("name$langID");
					if(strlen($rootName)) {
						if(strpos($this->it, $rootName . "/") === 0){
							$this->langSegment = $rootName;
							// $new_it = substr($this->it,strlen($this->langSegment)+1);
							$this->it = substr($this->it,strlen($this->langSegment)+1);
						}
					}
				}
			}

			$langSegment = $this->langSegment ? $this->langSegment . "/" : "";

			// we modify the GET it to tell PW what page to load
			$_GET['it'] = (isset($_GET['it']))
					? "$langSegment{$domainPageName}/" . $this->it
					: "$langSegment{$domainPageName}/";
		}

		if(!$this->isAdmin) {
			$this->addHookAfter('Page::render', $this, 'hookPageRender');
		}

	}


	public function ready() {

	}

	public function hookPageRender(HookEvent $event){

		// $timer = Debug::Timer();
		$out = $event->return;
		$out = $this->parseLinks($out);
		$event->return = $out;
		// wire("log")->save("multisite", "timer: ". Debug::Timer($timer));

	}

	public function ___parseLinks($out){

		if(!strlen($out)) return $out;

		foreach($this->domains as $key => $domain){

			if($this->modules->isInstalled("LanguageSupportPageNames")) {
				foreach($this->languages as $lang) {
					$langID = $lang->id;
					if($lang->isDefault()) $langID = '';

					$rootPage = $this->pages->get(1);
					$rootName = $rootPage->get("name$langID");
					if($rootName == "home") $rootName = "";
					if(strlen($rootName)) $rootName = "/" . $rootName;

					if($key == $this->domain){
						// internal relative urls
						$replace = array(
							"\"$rootName/{$domain['root']}/",
							"'$rootName/{$domain['root']}/",
							);
						$with = array(
							"\"$rootName/",
							"'$rootName/",
							);
						// echo (" - " . $replace . " / " . $with);
					} else {
						// external urls
						$replace = array(
							"\"$rootName/{$domain['root']}/",
							"'$rootName/{$domain['root']}/",
							"\"http://{$key}$rootName/{$domain['root']}/",
							"'http://{$key}$rootName/{$domain['root']}/",
							);
						$with = array(
							"\"http://{$key}$rootName/",
							"'http://{$key}$rootName/",
							"\"http://{$key}$rootName/",
							"\'http://{$key}$rootName/",
							);
						// echo (" - " . $replace . " / " . $with);
					}
					$out = str_replace($replace, $with, $out);
				}

			} else {

				if($key == $this->domain){
					// local urls
					$replace = array(
						"\"/" . $domain['root'] . "/",
						"'/" . $domain['root'] . "/",
						);
					$with = array(
						"\"/",
						"'/",
						);
				} else {
					// external urls
					$replace = array(
						"\"/" . $domain['root'] . "/",
						"'/" . $domain['root'] . "/",
						"\"http://$key/" . $domain['root'] . "/",
						"'http://$key/" . $domain['root'] . "/",
						);
					$with = array(
						"\"http://" . $key . "/",
						"'http://" . $key . "/",
						"\"http://" . $key . "/",
						"'http://" . $key . "/",
						);
				}
				$out = str_replace($replace, $with, $out);
			}
		}

		return $out;
	}


	/**
	 * This method creates the "view" url used by the module
	 * @param  Page   $page a ProcessWire page object we want to get back the url
	 * @return string       the new url
	 */
	public function getDomainUrl(Page $page){
		$domainPageName = $page->rootParent->name;

		$found = false;
		foreach($this->domains as $domain => $d){
			if($d['root'] == $domainPageName){
				$found = true;
				break;
			}
		}

		if(!$found) return;

		// if(!array_key_exists($domainPageName, $this->domains)) return false;

		switch($page->template->https) {
			case -1: $protocol = 'http'; break;
			case 1: $protocol = 'https'; break;
			default: $protocol = $this->wire('config')->https ? 'https' : 'http';
		}

		$newurl = $protocol . "://" . $domain . $page->url;
		return $newurl;
	}

	public function _checkDomainInUrl(){
		// in case we find a multisite root domain in request path, we redirect to the correct domain/url
		$cleanIt = rtrim($this->it, "/");
		$dfound = false;
		foreach($this->domains as $key => $domain){

			// is root name found in url, NOTE: "domain" would match with "domainB", so
			// we need additional checks
			if(strpos($cleanIt, $domain['root']) !== false) {

				if($cleanIt == $domain['root']){
					// we found a 1:1 match
					// echo("found: " . $cleanIt . " -> " . $domain['root']);
					$dfound = true;
				} else if(strpos($cleanIt, "/") !== false){
					$firstSegment = substr($cleanIt, 0, strpos($cleanIt, "/"));

					if($firstSegment == $domain['root']){
						$dfound = true;
					} else {
						// when using multilanguage page names, domain root name may in second segment
						$cleanIt = substr($cleanIt, strpos($cleanIt, "/") + 1);
						if(strpos($cleanIt, "/") !== false) {
							$firstSegment = substr($cleanIt, 0, strpos($cleanIt, "/"));
						} else {
							$firstSegment = $cleanIt;
						}
						if($firstSegment == $domain['root']){
							$dfound = true;
						}
					}
				}

				if($dfound) {
					if(strpos($this->it, $domain['root'] . "/") !== false){
						$url = str_replace("{$domain['root']}/", '', $this->it);
					} else {
						$url = str_replace("{$domain['root']}", '', $this->it);
					}
					$protocol = $this->wire('config')->https ? 'https' : 'http';
					$url = $protocol . "://" . $key . "/" . $url;
					$this->session->redirect($url);
				}

			}
		}

	}


	/**
	 * Set the 404 page id
	 * @param  string $domain the domain
	 * @return [type]         [description]
	 */
	public function ___set404Page($domain){
		if($this->domains[$domain]){
			wire("config")->http404PageID = (int) $this->domains[$domain]['http404'];
		}
	}
}